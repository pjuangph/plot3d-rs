rd_("AhI-direction is constant.AhJ-direction is constant.AhK-direction is constant.BiBackward and forward differences along i.BiBackward and forward differences along j.BiBackward and forward differences along k.BiBackward and forward differences along p.BiBackward and forward differences along q.BeIdentifier, if one has been assigned.AeCreate an empty face.ChQuadrilateral face definition that mimics the Python \xe2\x80\xa6CbDimensions of the face grid <code>(nu, nv)</code>.BfFace dimensions <code>(nu, nv)</code>.AoReturns the argument unchanged.0000000000000000000BcMaximum I index among the vertices.BcMinimum I index among the vertices.BaCalls <code>U::from(self)</code>.0000000000000000000BcMaximum J index among the vertices.BcMinimum J index among the vertices.BcMaximum K index among the vertices.BcMinimum K index among the vertices.DjAlias for [<code>npoints</code>]. Returns <code>imax * jmax * kmax</code>.CkGraph partitioning utilities for structured multi-block \xe2\x80\xa6CiMultiply all coordinates by <code>factor</code> in place.D`Shift all stored vertices by <code>(dx, dy, dz)</code> in place.CiFlattened coordinates stored row-major in <code>u</code>.CkCompute the (unnormalized) geometric normal using three \xe2\x80\xa6CgPlot3D utilities for mesh connectivity, periodicity \xe2\x80\xa6DbReturn a new block with coordinates scaled by <code>factor</code>.BgSet the application-defined identifier.CjIterate over stored vertex indices <code>(i, j, k)</code>.BhTrue when the face collapses to an edge.CjReconstruct a Face from this record using the provided \xe2\x80\xa6EbReturns <code>true</code> if <code>overlap_fraction &gt;= min_overlap_frac</code>.CiCSR (Compressed Sparse Row) representation of a block \xe2\x80\xa6DkBackward and forward difference pair: <code>(backward, forward)</code>. \xe2\x80\xa6CnEnumeration describing which index remains constant over a \xe2\x80\xa6CgData for a single block boundary face (a 2D grid of \xe2\x80\xa6C`Differencing data at a single node on a 2D face.DkAdjacency list: <code>adj_list[u]</code> is a sorted, deduplicated list \xe2\x80\xa6AfRetrieve the centroid.B`All I indices used by this face.CmTrue when the face collapses to a single point (all three \xe2\x80\xa6B`All J indices used by this face.B`All K indices used by this face.CaDifferencing data at a single node in a 3D block.BoAggregates the matching data between two faces.CaReturn parametric face size in index-space cells.BhConstruct a record from a Face instance.CjReturn the six boundary faces as a map keyed by face name.DePrint the XYZ coordinates at <code>(i, j, k)</code> in a readable \xe2\x80\xa6CfExtract a sub-block defined by inclusive index ranges.DhExport a <code>FaceRecord</code> representation mirroring the Python \xe2\x80\xa6CaAdjacency and edge-weight data for a block graph.CgCompact record describing a face on a particular block.CdDescribe a single coincident node between two faces.BeAdd a vertex and update the centroid.CeDetermine which index is constant, if the face is \xe2\x80\xa6CgCompute forward and backward differences along each \xe2\x80\xa6CkSplit a face into subfaces along the specified diagonal \xe2\x80\xa6AoOwning block index, if present.CgConvert to cylindrical coordinates (rotation axis = X).CkCompare two structured faces and determine whether they \xe2\x80\xa6CjStructured face points (dense sampling) for node matching.CcPoint matching utilities for structured grid faces.CnFind the indices of the closest point in a 2D face grid to \xe2\x80\xa6CfBlock splitting utilities that preserve multi-grid \xe2\x80\xa6CgWrite ddcmp.dat and ddcmp_info.txt files for domain \xe2\x80\xa6CbExportable description of a periodic face pairing.ChCompute volume of each cell using the Davies-Salmond \xe2\x80\xa6CnDetermine face-to-face connectivity and exterior faces for \xe2\x80\xa6CiForward and backward differencing for structured grid \xe2\x80\xa6DfEdge weights: <code>edge_weights[u][v]</code> = communication cost \xe2\x80\xa6BgCompare index ranges with another face.BiRead an AP NASA Fortran unformatted file.BlRotate a block using a 3\xc3\x973 rotation matrix.DgSplit blocks to achieve approximately <code>ncells_per_block</code> \xe2\x80\xa6BiDeduplicate index pairs (order-agnostic).EcFind vertex-index correspondences between <code>self</code> and <code>other</code>.DhReduce blocks by sampling every <code>factor</code> nodes along each \xe2\x80\xa6CeScale all stored index values by <code>factor</code>.BnScale the index ranges by <code>factor</code>.CoUpscale both participating face records by <code>factor</code>.ChResult type for <code>combine_blocks_mixed_pairs</code>.BgDirection along which to split a block.CiHelper structure representing a structured face grid. \xe2\x80\xa6C`Reduce the index ranges by <code>divisor</code>.DbDownscale both participating face records by <code>divisor</code>.CnStrategy for combining weights when multiple faces connect \xe2\x80\xa6EcGraph helper: find a neighbour connected to both <code>a</code> and <code>b</code>.CjLength of the face diagonal between the extreme corner \xe2\x80\xa6CgCompute forward and backward differences along each \xe2\x80\xa6CfBuild the six outer faces for a block and identify \xe2\x80\xa6AkSet the owning block index.BjCompare vertex positions with a tolerance.C`Helper trait to print summaries of face matches.C`Helper trait to print summaries of face records.BlCompute the global bounds across all blocks.CmCompute the maximum cell aspect ratio at the 8 corners of \xe2\x80\xa6CkCompute the overlap area fraction between this face and \xe2\x80\xa6CdDecide if another face shares enough nodes to be \xe2\x80\xa6CiConnectivity computation performed on GCD-reduced blocks.CaSimple collinearity test using the cross product.CbFind the block whose centroid is closest to an \xe2\x80\xa6CmIdentify outer faces on the extreme of the requested axis \xe2\x80\xa6C`Determine whether any faces on two blocks match.DbConvert serialized matched faces to a flat <code>Face</code> list.ClRotate the entire mesh by an arbitrary angle and recover \xe2\x80\xa6DcConvert a <code>BlockGraph</code> to CSR arrays suitable for METIS.CeRecursively match all faces between a pair of blocks.CnCompute the coincident nodes between two faces on separate \xe2\x80\xa6DgFraction of shared grid nodes between this face and <code>other</code>.BoOptions for the block connectivity calculation.BgRotation matrix for the requested axis.CeIdentify rotationally periodic face pairs without \xe2\x80\xa6CeUtilities for detecting rotational periodicity in \xe2\x80\xa6CnConnectivity matrices describing which faces touch between \xe2\x80\xa6BkPick the face closest to a reference point.BkConvert face matches into an adjacency map.CcRotate a block using a precomputed rotation matrix.CeCompute outward normals for the six faces of a block.CgTranslational periodicity utilities that mirror the \xe2\x80\xa6ClDetect translational periodicity along an axis. Discover \xe2\x80\xa6CgAttempt to merge as many blocks as possible from an \xe2\x80\xa6CbBuild a face from diagonal index pairs on a block.DfConvert serialized face records back into <code>Face</code> instances.CmDetect rotational periodicity after reducing grids by the \xe2\x80\xa6CjStandardise block orientation so that indices increase \xe2\x80\xa6ChMerge two compatible blocks by aligning and stacking \xe2\x80\xa6CgMerge all discoverable n\xc3\x97n\xc3\x97n cube groupings using \xe2\x80\xa6BlBuild a weighted graph from face-match data.")